{"meta":{"title":"littlejuruo","subtitle":null,"description":null,"author":"littlejuruo","url":"littlejuruo.github.io","root":"/"},"pages":[{"title":"","date":"2019-11-08T03:34:49.139Z","updated":"2019-11-08T03:34:49.139Z","comments":true,"path":"about/index.html","permalink":"littlejuruo.github.io/about/index.html","excerpt":"","text":"说明我是littlejuruo,目前正在读初中，一位oier. 账号luogu: https://www.luogu.org/user/175567 jisuanke: https://i.jisuanke.com/u/dsc200h nowcoder: https://www.nowcoder.com/profile/508349525 奖项CSP2019 （J1）： 入围"},{"title":"友情链接","date":"2019-11-08T03:21:29.796Z","updated":"2019-11-08T03:15:31.828Z","comments":true,"path":"friends/index.html","permalink":"littlejuruo.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"搜索之连通块（深搜广搜版）","slug":"1","date":"2019-11-08T03:47:10.206Z","updated":"2019-11-08T04:03:52.147Z","comments":true,"path":"2019/11/08/1/","link":"","permalink":"littlejuruo.github.io/2019/11/08/1/","excerpt":"","text":"连通块模板用法：c++ 输入数据：0/1矩阵，若标准输入不是0/1矩阵，请转换。转换0/1矩阵，你可能需要形如这样的代码： 12345char chswitch(ch) &#123; case '墙': &#123;s[i][j] = 0;break;&#125; case '空地': &#123;s[i][j] = 1;break;&#125; &#125; 适合问题：连通块 &lt;kbd&gt;广度优先搜索版：&lt;/kbd&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int x; int y; node()&#123;&#125; node(int x1,int y1):x(x1),y(y1)&#123;&#125; &#125;;int n,m;int u[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; int head=1;int tail=1;int s[105][105];int sum=0;void bfs(int x,int y)&#123; queue&lt;node&gt;Q; s[x][y]=0; Q.push(node(x,y)); while(!Q.empty())&#123; node a=Q.front(); Q.pop(); for(int i=0;i&lt;4;i++)&#123; int xx=u[i][0]+a.x; int yy=u[i][1]+a.y; if(xx&gt;=0&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;m&amp;&amp;(s[xx][yy]))&#123; s[xx][yy]=0; Q.push(node(xx,yy)); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;s[i][j]; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(s[i][j])&#123; sum++; bfs(i,j); &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; ​ 深度优先搜索版： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;bool vis[1005][1005];int maze[1005][1005];int ans, cnt;int dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;bool in(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;&#125;void dfs(int x, int y) &#123; cnt++; vis[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int tx = x+dir[i][0]; int ty = y+dir[i][1]; if(in(tx,ty)&amp;&amp;!vis[tx][ty]&amp;&amp;maze[tx][ty]==1) &#123; dfs(tx,ty); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0;i&lt;n;++i) &#123; for(int j = 0;j&lt;m;++j) &#123; cin&gt;&gt;maze[i][j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (maze[i][j] == 1 &amp;&amp; !vis[i][j]) &#123; cnt = 0; dfs(i, j); ans ++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]}]}